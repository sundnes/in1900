# This DocOnce file was automatically generated by the latexslides
# program (see http://code.google.com/p/latexslides).

% User's newcommands:
\newcommand{\emp}[1]{{\smaller\texttt{#1}}}
\newcommand{\mathbfx}[1]{{\mbox{\boldmath $#1$}}}




TITLE: A Complete Project: Oscillating Systems (Appendix D)
AUTHOR: Hans Petter Langtangen at Simula Research Laboratory
\and
University of Oslo, Dept.~of Informatics
DATE: April 24, 2014


!split
===== Now we want to solve a complete problem (oscillatory motion) =====


!bblock
  * Box attached to spring with moving end point:
!eblock

FIGURE: [../manu/figs/box_spring_sketch.eps, width=300 frac=0.5]

!split
===== How can we model such a system mathematically? =====

!bblock
  * The motion of the box is caused by forces
  * Newton's 2nd law relates motion (acceleration) to forces:
     \[ F = ma\]
     $F$: sum of all forces on the box, $m$: mass of the box, $a$: acceleration of the box
     
  * The goal of the computations is to find the position of the box, $Y$, as a function of time $t$; if we know $Y(t)$ we can find all other interesting physical quantities
  * We can set up
     \[ Y(t) = w(t) - (L + S(t)) - {b\over2}\]
     Known: $w(t),\ L,\ b$; unknown: stretch of spring $S(t)$ 
     
!eblock

!split
===== About this problem =====

!bblock
  * This is our first "real-life" problem
  * Such problems, from science and technology, is a mix of physics (biology, finance, ...), mathematics, programming and applications of many computer programs
  * Programming is only one piece of the problem solving process
  * All programmers either need knowledge of the application field (physics, math, biology, finance) OR they need to interact with application experts
  * Multi-disciplinary problem solving is very important - that is why we work through the present example!
  * But we shall keep our main focus on programming issues
!eblock

!split
===== All physics and math boil down to a governing equation =====

!bblock
  * From Newton's 2nd law++ one can derive an equation for $S(t)$:
\[
m{d^2S\over dt^2} + \beta {dS\over dt} + kS =
m{d^2w\over dt^2} + mg
\]
  * This is a *differential equation* (DE), i.e., an equation where the unknown is a function (here $S(t)$)
  * Most physical problems can be described mathematically as one or more differential equations
  * Differential equations are very difficult to solve with pen and paper, but large classes of such equations are quite easy to solve with a computer
!eblock

!split
===== How to compute $S(t)$ =====

!bblock
  * We will solve the DE for $S_i\equiv S(t_i)$, $i=0, 1, 2, \ldots, N$, $t_i=i\Delta t$ (i.e., we find $S(t)$ at $N+1$ discrete points in time)
  * The differential equation can be solved by this algorithm:
\begin{itemize}
\item Set $S_0$ from input data
\item Compute $S_1$ by
\[
S_{i+1}
= {1\over 2m}\left(
2mS_i
- \Delta t^2\, kS_i 
+ m\left(w_{i+1} -2w_i + w_{i-1} \right)
+ \Delta t^2\, mg\right),
\]
with $i=0$.
\item For $i=1,2,\ldots,N-1$, compute $S_{i+1}$ by
\begin{eqnarray*}
S_{i+1}
= (m + \gamma)^{-1}\bigl(
&&2 mS_i - mS_{i-1}
+ \gamma \Delta t\, S_{i-1}
- \Delta t^2\, kS_i 
+\nonumber<linebreak>
&& m(w_{i+1} -2w_i + w_{i-1})
+ \Delta t^2\, mg\bigr)
\end{eqnarray*}
\end{itemize}
  
  * As a programmer, you don't need to understand the physics and mathematics behind this algorithm, but you must be able to program it!
!eblock

!split
===== Program overview (input, output, objects) =====

!bblock
  * Input data: 
    * $m$: the mass of the box
    * $b$: the height of the box
    * $L$: the length of the unstretched spring
    * $\beta$: coefficient for the damping force
    * $k$: coefficient for the spring force
    * $\Delta t$: the time step between each $S_i$ calculation
    * $N$: the number of computed time steps
    * $S_0$: the initial stretch of the spring
    * $w(t)$: the vertical displacement of the plate
    * $g$: acceleration of gravity
  * Output data: $S(t_i)$, $i=0,\ldots,N$ (list)
  * Objects: `float`, `int`, `list`, functions
!eblock

!split
===== Handling input data in the program =====

!bblock
!bc pycod
def init_prms(m, b, L, k, beta, S0, dt, g, w_formula, N):
    import getopt, sys
    try:
        options, args = getopt.getopt(
            sys.argv[1:], '', 
            ['m=', 'mass=',
             'b=', 'boxheight=',
             ...
            'N='])
    except getopt.GetoptError, e:
        print 'Error in command-line option:', e
        sys.exit(1)

    for option, value in options:
        if option in ('--m', '--mass'):
            m = float(value)
        elif option in ('--b', '--boxheight'):
            b = float(value)
        ...
        elif option == '--N':
            N = int(value)

    from scitools.StringFunction import StringFunction
    w = StringFunction(w_formula, independent_variables='t')
    return m, b, L, k, beta, S0, dt, g, w, N
!ec
!eblock

!split
===== Implementation of the solution algorithm =====

!bblock
!bc pycod
def solve(m, k, beta, S0, dt, g, w, N):
    S = [0.0]*(N+1)      # output list
    gamma = beta*dt/2.0  # short form
    t = 0
    S[0] = S0
    # special formula for first time step:
    t = dt
    i = 0
    S[i+1] = (1/(2.0*m))*(2*m*S[i] - dt**2*k*S[i] + 
             m*(w(t+dt) - 2*w(t) + w(t-dt)) + dt**2*m*g)

    for i in range(1,N):
        S[i+1] = (1/(m + gamma))*(2*m*S[i] - m*S[i-1] +
                 gamma*dt*S[i-1] - dt**2*k*S[i] +
                 m*(w(t+dt) - 2*w(t) + w(t-dt))
                 + dt**2*m*g)
        t += dt
    return S
!ec
!eblock

!split
===== A main program =====

!bblock
!bc pycod
# default values:
from math import pi
m = 1; b = 2; L = 10; k = 1; beta = 0; S0 = 1;
dt = 2*pi/40; g = 9.81; w_formula = '0'; N = 80; 

m, b, L, k, beta, S0, dt, g, w, N = \ 
   init_prms(m, b, L, k, beta, S0, dt, g, w_formula, N)
S = solve(m, k, beta, S0, dt, g, w, N)
print S
!ec
!eblock

!split
===== Callback functionality =====

!bblock
  * Sometimes we want to do something "special" inside the `solve` function, e.g., visualize the $S(t)$ solution, while the program is running
  * We can of course insert whatever statements we like in `solve`
  * However, editing `solve` frequently can easily lead to bugs
  * Much better: let `solve` call a problem-specific function, provided as argument to `solve`
  * We will then have a general `solve` function for "all" problems, and any problem-specific actions inside `solve` is encapsulated in a separate function
  * This principle is very common in larger programs
  * The problem-specific function is called a *callback* function (`solve` "calls back" to the user's callback function)
  * Vey easy to program, very powerful technique
!eblock

!split
===== Implementing the callback functionality (part 1) =====

!bblock
  * In `solve`:

!bc pycod
def solve(m, k, beta, S0, dt, g, w, N,
          user_action=lambda S, time, time_step_no: None):

    S = [0.0]*(N+1)      # output list
    gamma = beta*dt/2.0  # short form
    t = 0
    S[0] = S0
    user_action(S, t, 0)
    # special formula for first time step:
    t = dt
    i = 0
    S[i+1] = ...
    user_action(S, t, i+1)

    # time loop:
    for i in range(1,N):
        S[i+1] = ...
        t += dt
        user_action(S, t, i+1)
    return S
!ec
!eblock

!split
===== Implementing the callback functionality (part 2) =====

!bblock
  * In the main program:

!bc pycod
def print_S(S, t, step):
    print 't=%.2f  S[%d]=%+g' % (t, step, S[step])

# default values:
m = 1; b = 2; L = 10; k = 1; ....

m, b, L, k, beta, S0, dt, g, w, N = \  
   init_prms(m, b, L, k, beta, S0, dt, g, w_formula, N)
S = solve(m, k, beta, S0, dt, g, w, N,
          user_action=print_S)
!ec
!eblock

!split
===== Organization of the program =====

!bblock
  * The input and solve functions are general and can be used to solve many different physical problems involving oscillating systems
  * We therefore collect `init_prms` and `solve` in a module
  * Problem-specific applications import from the module and supply a problem-specific main program (with a callback function, if needed)
  * Module: `box_spring.py` in `src/input`
  * First application: test if we start at rest, the system will continue to be at rest
  * Main program: set default values, call `init_prms`, call `solve`, either callback with `print_S` (print at each time level) or just `print S` after `solve(...)`
!eblock

!split
===== Check if nothing happens if $S_0=0$ (no initial stretch) =====

!bblock
  * We run

!bc sys
Terminal> python box_spring_test0.py --S0 0
!ec

  * Output:

!bc pycod
t=0.00  S[0]=+0
t=0.16  S[1]=+0.121026
t=0.31  S[2]=+0.481118
!ec
 Ooops!
  * What is wrong???
  * Two possibilities: 1) a physicist has precisely given a test problem to us with input and output, or 2) we need to understand the problem being solved
  * If 2: gravity pulls the box downward, resulting in motion
  * If 1: $g$ as input would have been specified to 0
  * Note: finding such errors is difficult - at least before you have taken a physics course and learned much more about the problem
!eblock

!split
===== Adding graphics =====

!bblock
  * The real use of the callback function is for adding graphics such that we can view the solution while it is being computed
  * With some tools from Chapter 4 we can do this
  * Resulting program: `box_spring_plot.py`
  * Example 1: initial stretch but no gravity (pure cosine oscillations, analytical solution),

!bc sys
Terminal> python box_string_plot.py --S0 0 --N 200
!ec
$S(t)=g(1-\cos t)$
  * Example 2: Sudden movement of the plate (no gravity, no initial stretch),

!bc sys
Terminal> python box_spring_plot.py \ 
          --w '1 if t > 0 else 0' \ 
          --S 0 --g 0 --N 1000 --beta 0.1
!ec
!eblock

!split
===== Graphs of the box movement ($Y$) =====

FIGURE: [../manu/figs/box_spring_plot2.eps, width=600 frac=1.0]

!split
===== Magnification of the first cycles =====

FIGURE: [../manu/figs/box_spring_plot3.eps, width=600 frac=1.0]

!split
===== Plot of the oscillating box =====

!bblock
  * Module `box_spring` contains two functions:
    * `init_prms` for reading command-line parameters
    * `solve` which returns the solution $S(t)$ as a list `S`
  * Now we want to plot the solution $S(t)$ (stretch of the spring) or $Y(t)$ (position of the box, $Y=w-L-S-b/2$) while the program is computing $S$
  * Later, we will perform other (and more) plots
!eblock

!split
===== Simultaneous computation and visualization =====

!bblock
  * `solve` has a callback function `user_action(S,t,step)`
  * We shall provide a callback function that plots $Y$ against $t$ at every time step
  * `S` has length `N+1`, final time is `N*dt`, when the callback function is called, `S[0:step]` is filled with computed values (the rest is 0)

!bc pycod
def plot_S(S, t, step):
    if step == 0:        # nothing to plot yet
        return None
    
    tstart = 0
    tstop = N*dt
    tcoor = linspace(0, t, step+1)

    S = array(S[:len(tcoor)])
    Y = w(tcoor) - L - S - b/2.0
    plot(tcoor, Y)
!ec

  * Note: it's nontrivial to count right (`tstop`, `tcoor`)
!eblock

!split
===== The main program =====

!bblock
  

!bc pycod
from box_spring import init_prms, solve
from scitools.std import *

def plot_S(S, t, step):
    ...
    plot(tcoor, Y)
    
# default values:
m = 1; b = 2; L = 10; k = 1; beta = 0; S0 = 1;
dt = 2*pi/40; g = 9.81; w_formula = '0'; N = 200;

m, b, L, k, beta, S0, dt, g, w, N = \  
   init_prms(m, b, L, k, beta, S0, dt, g, w_formula, N)

# magic needed for StringFunction if w shall take arrays
# as argument (and it does in plot_S):
w.vectorize(globals())

S = solve(m, k, beta, S0, dt, g, w, N, user_action=plot_S)
!ec
!eblock

!split
===== Comparing several quantities in subplots (part 1) =====

!bblock
After $Y$ and $S$ are computed, it is interesting to plot several other quantities: $w(t)$, the spring force (proportional to $S$ so we can just plot $S$), the damping force $-\beta dS/dt$
!eblock

!bblock
  

!bc pycod
S = solve(m, k, beta, S0, dt, g, w, N, user_action=plot_S)
hardcopy('tmp_Y.eps')

tstart = 0
tstop = N*dt
tcoor = linspace(0, tstop, N+1)
S = array(S)

plots = 2         # number of rows of plots
if beta != 0:
    plots += 1
if w_formula != '0':
    plots += 1

# position Y(t):
plot_row = 1
subplot(plots, 1, plot_row)
Y = w(tcoor) - L - S - b/2.0
plot(tcoor, Y, xlabel='time', ylabel='Y')
!ec
!eblock

!split
===== Comparing several quantities in subplots (part 2) =====

!bblock
  

!bc pycod
# spring force (and S):
plot_row += 1
subplot(plots, 1, plot_row)
Fs = k*S
plot(tcoor, Fs, xlabel='time', ylabel='spring force')

if w_formula != '0':
    plot_row += 1
    subplot(plots, 1, plot_row)
    w_array = w(tcoor)
    plot(tcoor, w_array, xlabel='time', ylabel='w(t)')

hardcopy('tmp.eps')
!ec
!eblock

!split
===== Try it out! (1) =====


!bblock
`--S0 1 --g 0  --N 300`
!eblock

FIGURE: [../manu/figs/box_spring_demo1.eps, width=570 frac=0.9]

!split
===== Try it out! (2) =====


!bblock
`--S0 0 --g 0 --w 'sin(1.3*t)' --N 600`
!eblock

FIGURE: [../manu/figs/box_spring_demo2.eps, width=570 frac=0.9]

!split
===== Try it out! (3) =====


!bblock
`--S0 0 --w '2*(cos(8*t)-1)' --N 600 --dt 0.05236`
!eblock

FIGURE: [../manu/figs/box_spring_demo3.eps, width=570 frac=0.9]

!split
===== Try it out! (4) =====


!bblock
`--S0 0.5 --w '6*(cos(0.3*t)-1)' --beta 0.3 --N 400`
!eblock

FIGURE: [../manu/figs/box_spring_demo4.eps, width=570 frac=0.9]

!split
===== Try it out! (5) =====


!bblock
`--S 0 --g 0 --w '1 if t > 0 else 0' --N 1000 --beta 0.1`
!eblock

FIGURE: [../manu/figs/box_spring_demo5.eps, width=570 frac=0.9]


